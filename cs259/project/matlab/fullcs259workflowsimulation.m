%% obtain data
clear all;
load('~/Desktop/cs259demodata.mat')
%% create data structures
% constants
%choose hilbert algorithm
whatHilbert = 'delay'; % 'fir' 'diff' 'delay'
bitvolts = 0.015624999960550667; % microvolts per bit
powerThreshold = 60; % microvolts
phaseSegmentsDesired = 10; % divisions of the phase of theta
nativeSampleRate = 32000; % Hz
downsampleRate = 250; % Hz
everyNthSample = round(nativeSampleRate/downsampleRate); % 128 samples of each 32,000 (Hz) is 250 Hz
%lowpassDenominatorCoeffs = ;
lowpassNumeratorCoeffs = [                    ...
   0.000000000006564694180131090961704897522  ...
   0.000000000039388165080786542539055117347  ...
   0.000000000098470412701966356347637793367  ...
   0.000000000131293883602621825696446486011  ...
   0.000000000098470412701966356347637793367  ...
   0.000000000039388165080786542539055117347  ...
   0.000000000006564694180131090961704897522  ];
lowpassDenominatorCoeffs = [                  ...
   1                                          ... % supposed to be 1? but equations indicate 0?
  -5.893323981110579090625378739787265658379  ...
  14.472294910655531197107848129235208034515  ...
 -18.955749009589681008947081863880157470703  ...
  13.966721637745113326900536776520311832428  ...
  -5.488755923739796926952294597867876291275  ...
   0.898812366459551981279219035059213638306  ];
lowpassNumeratorCache = zeros(1,length(lowpassDenominatorCoeffs));
lowpassDenominatorCache = zeros(1,length(lowpassNumeratorCoeffs));
bandpassDenominatorCoeffs = [ 1	-3.88599460271612	5.72599691256117	-3.79036782331802	0.951396799109592 ];
bandpassNumeratorCoeffs = [ 0.000302732421439697	0	-0.000605464842879194	0	0.000302732421499597 ];
bandpassCache = zeros(1,max(length(bandpassNumeratorCoeffs),length(bandpassDenominatorCoeffs)));
hilbertNumeratorCoeffs = ...                                
 [ 0                                       ...
-0.000130476138946636967567635490006239252 ...
 0                                         ...
-0.000202974874492264191006354878688000554 ...
 0                                         ...
-0.000354719283426647362215955450182036657 ...
 0                                         ...
-0.000575250463727568087449193434679273196 ...
 0                                         ...
-0.000883857088375641052058195867857648409 ...
 0                                         ...
-0.001303301689776132678277864584970302531 ...
 0                                         ...
-0.00185939798324038021992699043494212674  ...
 0                                         ...
-0.002581673560742158042569105447228139383 ...
 0                                         ...
-0.003503797920068961457840117645901045762 ...
 0                                         ...
-0.004664131994992812280109717448794981465 ...
 0                                         ...
-0.006106840275994708522322440558127709664 ...
 0                                         ...
-0.007883785040501717356065114472585264593 ...
 0                                         ...
-0.010057477023547291283822602281361469068 ...
 0                                         ...
-0.012705784627037419731721001880941912532 ...
 0                                         ...
-0.015929742752346390255446806349937105551 ...
 0                                         ...
-0.019866759569211356328821693750796839595 ...
 0                                         ...
-0.024713514254879220821692342724418267608 ...
 0                                         ...
-0.030767476745944988270053954693139530718 ...
 0                                         ...
-0.038507103880309478949328649832750670612 ...
 0                                         ...
-0.048759874539129832715644852214609272778 ...
 0                                         ...
-0.063094520517915864132874048664234578609 ...
 0                                         ...
-0.084885445881223930975068014959106221795 ...
 0                                         ...
-0.122931145484904802422931879846146330237 ...
 0                                         ...
-0.209544916583793261466439616924617439508 ...
 0                                         ...
-0.635728180480658489059919702413026243448 ...
 0                                         ...
 0.635728180480658489059919702413026243448 ...
 0                                         ...
 0.209544916583793261466439616924617439508 ...
 0                                         ...
 0.122931145484904802422931879846146330237 ...
 0                                         ...
 0.084885445881223930975068014959106221795 ...
 0                                         ...
 0.063094520517915864132874048664234578609 ...
 0                                         ...
 0.048759874539129832715644852214609272778 ...
 0                                         ...
 0.038507103880309478949328649832750670612 ...
 0                                         ...
 0.030767476745944988270053954693139530718 ...
 0                                         ...
 0.024713514254879220821692342724418267608 ...
 0                                         ...
 0.019866759569211356328821693750796839595 ...
 0                                         ...
 0.015929742752346390255446806349937105551 ...
 0                                         ...
 0.012705784627037419731721001880941912532 ...
 0                                         ...
 0.010057477023547291283822602281361469068 ...
 0                                         ...
 0.007883785040501717356065114472585264593 ...
 0                                         ...
 0.006106840275994708522322440558127709664 ...
 0                                         ...
 0.004664131994992812280109717448794981465 ...
 0                                         ...
 0.003503797920068961457840117645901045762 ...
 0                                         ...
 0.002581673560742158042569105447228139383 ...
 0                                         ...
 0.00185939798324038021992699043494212674  ...
 0                                         ...
 0.001303301689776132678277864584970302531 ...
 0                                         ...
 0.000883857088375641052058195867857648409 ...
 0                                         ...
 0.000575250463727568087449193434679273196 ...
 0                                         ...
 0.000354719283426647362215955450182036657 ...
 0                                         ...
 0.000202974874492264191006354878688000554 ...
 0                                         ...
 0.000130476138946636967567635490006239252 ...
 0];
hilbertNumeratorCoeffs = hilbertNumeratorCoeffs(41:61);
    hilbertCache = zeros(1,length(hilbertNumeratorCoeffs));
lowpassNCoeff = min(length(lowpassDenominatorCoeffs),length(lowpassNumeratorCoeffs));
bandpassNCoeff = min(length(bandpassDenominatorCoeffs),length(bandpassNumeratorCoeffs));
hilbertNCoeffs = length(hilbertNumeratorCoeffs);
delay_samples = round(downsampleRate/(6.95 * 4)) ; % the 6.95 is the center frequency of the bandpass filter; need a bank of these values normally
% for checking the results
lowpassed = zeros(size(lfp));
downsampled = zeros(size(lfp));
bandpassed = zeros(1,ceil(length(lfp)/everyNthSample));
hilberted = zeros(1,ceil(length(lfp)/everyNthSample));
angled = zeros(1,ceil(length(lfp)/everyNthSample));
enveloped = zeros(1,ceil(length(lfp)/everyNthSample));
thresholded = zeros(1,ceil(length(lfp)/everyNthSample));
digitized = zeros(1,ceil(length(lfp)/everyNthSample)); % what port is active? -1 == NULL


%% simulate the arrival of data samples
% cheat a little on the spool up
for idx=1: 320000 %length(lfp)
    
    %% lowpass
    % from http://www.ee.ic.ac.uk/pcheung/teaching/ee3_Study_Project/iir_lab2.pdf
    % iir xfer function : (might have errors...)
    % H(z) = ( b_0 + b_1 * z^-1 ... + b_n * z^-n ) / ( 1 + a_1 * z^-1 ... + a_n * z^-n )
    % becomes :
    % y(n)= b_0*x(n) + b_1*x(n-1) ...  + b_m*x(n-m) - a_1*y(n-1) ...  - a_m*y(n-m)
    % so basically, the result of the last calculation feeds into this one.
    % this means we can convert the calculation into linear algebra,
    % but we need to flip the coefficient order (better above than here,
    % really) because coef 0 should be multiplied by the current data, and
    % that will not happen in the normal orientations in matlab's dot
    % product  
    %lowpassed(idx) = sum(lowpassNumeratorCache.*lowpassNumeratorCoeffs) - sum(lowpassDenominatorCache.*lowpassDenominatorCoeffs);
    %lowpassNumeratorCache = [ lfp(idx) lowpassNumeratorCache(1:end-1) ]; % shift register  
    %lowpassDenominatorCache = [ lowpassed(idx) lowpassDenominatorCache(1:end-1) ];
    for k=1:min(idx,lowpassNCoeff) 
        lowpassed(idx) = lowpassed(idx) ...
            - lowpassed(idx-k+1)*lowpassDenominatorCoeffs(k)...
            + lfp(idx-k+1)*lowpassNumeratorCoeffs(k);
    end
   %% downsample
    
     if ( 0 == mod(idx, everyNthSample) )
         dsIdx = idx/everyNthSample;
         downsampled(dsIdx) = lowpassed(idx);
         %% bandpass  
        %bandpassCache = [ bandpassCache(2:end) lowpassed(idx) ]; % shift register
        %bandpassed(dsIdx) = bandpassCache*bandpassNumeratorCoeffs' + bandpassCache*-bandpassDenominatorCoeffs';
        for k=1:min(dsIdx,bandpassNCoeff) 
            bandpassed(dsIdx) = bandpassed(dsIdx) ...
                - bandpassed(dsIdx-k+1)*bandpassDenominatorCoeffs(k)...
                + downsampled(dsIdx-k+1)*bandpassNumeratorCoeffs(k);
        end
        %% hilbert -- done with FIR
        %
        if strcmp( whatHilbert, 'fir')
            % Andrew's version
            %hilbertCache = [ bandpassed(idx/everyNthSample) hilbertCache(1:end-1)  ];
            %hilberted(dsIdx)= sum(hilbertCache.*hilbertNumeratorCoeffs);
            %
            % Colin's Version
            for k=1:min(dsIdx,hilbertNCoeffs)
                hilberted(dsIdx)= hilberted(dsIdx) + ...
                                  bandpassed(dsIdx-k+1)*hilbertNumeratorCoeffs(k);
            end
        elseif strcmp( whatHilbert, 'diff' )
            % differentiation version with empirical gain factor
            %   * this works because hilbert(sin(t)) == -cos(t) 
            %     and sin'(t) = cos(t)
            %     therefore, especially inside a very tight bandpass filter
            %     hilbert(sin(t)) is roughly equivalent to - dv/dt (signal)
            if dsIdx > 1
                hilberted(dsIdx) =  5.3*(bandpassed(dsIdx-1) - bandpassed(dsIdx));
            end
        elseif strcmp( whatHilbert, 'delay' )
            % delay approximation
            % given :
            %   a tightly bandpassed signal 
            %   a hilbert is a 90 degree phase shift of a signal
            % then, it follows that
            %   a hilbert transform on the tightly bandpassed signal is
            %   approximately equal to the original signal delayed by 
            %   delay_samples = sample_rate/(center_freq * 4)
            if dsIdx > delay_samples
                hilberted(dsIdx) =  bandpassed(dsIdx-delay_samples);
            end
         end
         %% CORDIC
         [ angled(dsIdx) , enveloped(dsIdx)] = cordicVector(bandpassed(dsIdx),hilberted(dsIdx),20);
         %% threshold check
         if ( enveloped(dsIdx) * bitvolts < powerThreshold )
             % the output is NULL
             digitized(dsIdx) = -1;
         else
             %% map to digital out
             % i.e. what TTL is currently on
             digitized(dsIdx) = floor(angled(dsIdx)/(359/phaseSegmentsDesired));
         end
    end
end

figure;
trueHilbert = hilbert(bandpassed);
subplot(4,1,1); plot(bandpassed(1:500)); hold on;  plot(enveloped(1:500)); legend('bandpassed','envelope'); title(whatHilbert);
subplot(4,1,2); plot(angled(1:500)); hold on;  plot(360/(2*pi)*atan2(real(trueHilbert(1:500)),imag(trueHilbert(1:500)))); legend('CORDIC','atan2');
subplot(4,1,3); plot(bandpassed(1:500)); hold on; plot(hilberted(1:500)); legend('bandpassed','hilberted');
subplot(4,1,4); plot(bandpassed(1:500)); hold on; plot(imag(trueHilbert(1:500))); legend('bandpassed','true hilbert');