%% obtain data
clear all;
load('~/Desktop/cs259demodata.mat')
%% create data structures
% constants
bitvolts = 0.015624999960550667; % microvolts per bit
powerThreshold = 60; % microvolts
phaseSegmentsDesired = 10; % divisions of the phase of theta
nativeSampleRate = 32000; % Hz
downsampleRate = 250; % Hz
everyNthSample = round(nativeSampleRate/downsampleRate); % 128 samples of each 32,000 (Hz) is 250 Hz
%lowpassDenominatorCoeffs = ;
lowpassNumeratorCoeffs = [                    ...
   0.000000000006564694180131090961704897522  ...
   0.000000000039388165080786542539055117347  ...
   0.000000000098470412701966356347637793367  ...
   0.000000000131293883602621825696446486011  ...
   0.000000000098470412701966356347637793367  ...
   0.000000000039388165080786542539055117347  ...
   0.000000000006564694180131090961704897522  ];
lowpassDenominatorCoeffs = [                  ...
   1                                          ... % supposed to be 1? but equations indicate 0?
  -5.893323981110579090625378739787265658379  ...
  14.472294910655531197107848129235208034515  ...
 -18.955749009589681008947081863880157470703  ...
  13.966721637745113326900536776520311832428  ...
  -5.488755923739796926952294597867876291275  ...
   0.898812366459551981279219035059213638306  ];
lowpassNumeratorCache = zeros(1,length(lowpassDenominatorCoeffs));
lowpassDenominatorCache = zeros(1,length(lowpassNumeratorCoeffs));
bandpassDenominatorCoeffs = [ 1	-3.88599460271612	5.72599691256117	-3.79036782331802	0.951396799109592 ];
bandpassNumeratorCoeffs = [ 0.000302732421439697	0	-0.000605464842879194	0	0.000302732421499597 ];
bandpassCache = zeros(1,max(length(bandpassNumeratorCoeffs),length(bandpassDenominatorCoeffs)));
hilbertNumeratorCoeffs = ...                                
 [ 0.000000000000001127662575653774979689441 ...
-0.000130476138946636967567635490006239252 ...
 0.000000000000001084406434006142992862232 ...
-0.000202974874492264191006354878688000554 ...
 0.000000000000001306970218913347628410693 ...
-0.000354719283426647362215955450182036657 ...
 0.00000000000000246669069323427698405669  ...
-0.000575250463727568087449193434679273196 ...
 0.000000000000002806901698824692312863782 ...
-0.000883857088375641052058195867857648409 ...
 0.000000000000004339819138687855845588155 ...
-0.001303301689776132678277864584970302531 ...
 0.000000000000004555116984364625691741079 ...
-0.00185939798324038021992699043494212674  ...
 0.000000000000007196699404630617933781969 ...
-0.002581673560742158042569105447228139383 ...
 0.000000000000007487084802012430804420114 ...
-0.003503797920068961457840117645901045762 ...
 0.000000000000008765282697374901866514888 ...
-0.004664131994992812280109717448794981465 ...
 0.000000000000009638574345629789427635214 ...
-0.006106840275994708522322440558127709664 ...
 0.000000000000011729763644065942984460419 ...
-0.007883785040501717356065114472585264593 ...
 0.000000000000011521229975995736189508857 ...
-0.010057477023547291283822602281361469068 ...
 0.000000000000012821254253207087832683143 ...
-0.012705784627037419731721001880941912532 ...
 0.000000000000013170520384854908769943733 ...
-0.015929742752346390255446806349937105551 ...
 0.000000000000013162616998395538802510608 ...
-0.019866759569211356328821693750796839595 ...
 0.000000000000013291186108429386259346121 ...
-0.024713514254879220821692342724418267608 ...
 0.000000000000012940365701555507551359594 ...
-0.030767476745944988270053954693139530718 ...
 0.000000000000012540823779124972839215067 ...
-0.038507103880309478949328649832750670612 ...
 0.000000000000010583817777527944690031015 ...
-0.048759874539129832715644852214609272778 ...
 0.000000000000009652095623049988689913729 ...
-0.063094520517915864132874048664234578609 ...
 0.00000000000000868191076750970078165346  ...
-0.084885445881223930975068014959106221795 ...
 0.000000000000006027117295506470495021365 ...
-0.122931145484904802422931879846146330237 ...
 0.000000000000004386224423203370569983616 ...
-0.209544916583793261466439616924617439508 ...
 0.000000000000002006719327650789301782679 ...
-0.635728180480658489059919702413026243448 ...
 0                                         ...
 0.635728180480658489059919702413026243448 ...
-0.000000000000002006719327650789301782679 ...
 0.209544916583793261466439616924617439508 ...
-0.000000000000004386224423203370569983616 ...
 0.122931145484904802422931879846146330237 ...
-0.000000000000006027117295506470495021365 ...
 0.084885445881223930975068014959106221795 ...
-0.00000000000000868191076750970078165346  ...
 0.063094520517915864132874048664234578609 ...
-0.000000000000009652095623049988689913729 ...
 0.048759874539129832715644852214609272778 ...
-0.000000000000010583817777527944690031015 ...
 0.038507103880309478949328649832750670612 ...
-0.000000000000012540823779124972839215067 ...
 0.030767476745944988270053954693139530718 ...
-0.000000000000012940365701555507551359594 ...
 0.024713514254879220821692342724418267608 ...
-0.000000000000013291186108429386259346121 ...
 0.019866759569211356328821693750796839595 ...
-0.000000000000013162616998395538802510608 ...
 0.015929742752346390255446806349937105551 ...
-0.000000000000013170520384854908769943733 ...
 0.012705784627037419731721001880941912532 ...
-0.000000000000012821254253207087832683143 ...
 0.010057477023547291283822602281361469068 ...
-0.000000000000011521229975995736189508857 ...
 0.007883785040501717356065114472585264593 ...
-0.000000000000011729763644065942984460419 ...
 0.006106840275994708522322440558127709664 ...
-0.000000000000009638574345629789427635214 ...
 0.004664131994992812280109717448794981465 ...
-0.000000000000008765282697374901866514888 ...
 0.003503797920068961457840117645901045762 ...
-0.000000000000007487084802012430804420114 ...
 0.002581673560742158042569105447228139383 ...
-0.000000000000007196699404630617933781969 ...
 0.00185939798324038021992699043494212674  ...
-0.000000000000004555116984364625691741079 ...
 0.001303301689776132678277864584970302531 ...
-0.000000000000004339819138687855845588155 ...
 0.000883857088375641052058195867857648409 ...
-0.000000000000002806901698824692312863782 ...
 0.000575250463727568087449193434679273196 ...
-0.00000000000000246669069323427698405669  ...
 0.000354719283426647362215955450182036657 ...
-0.000000000000001306970218913347628410693 ...
 0.000202974874492264191006354878688000554 ...
-0.000000000000001084406434006142992862232 ...
 0.000130476138946636967567635490006239252 ...
-0.000000000000001127662575653774979689441];
    hilbertCache = zeros(1,length(hilbertNumeratorCoeffs));
lowpassNCoeff = min(length(lowpassDenominatorCoeffs),length(lowpassNumeratorCoeffs));
bandpassNCoeff = min(length(bandpassDenominatorCoeffs),length(bandpassNumeratorCoeffs));
hilbertNCoeffs = length(hilbertNumeratorCoeffs);
% for checking the results
lowpassed = zeros(size(lfp));
downsampled = zeros(size(lfp));
bandpassed = zeros(1,ceil(length(lfp)/everyNthSample));
hilberted = zeros(1,ceil(length(lfp)/everyNthSample));
angled = zeros(1,ceil(length(lfp)/everyNthSample));
enveloped = zeros(1,ceil(length(lfp)/everyNthSample));
thresholded = zeros(1,ceil(length(lfp)/everyNthSample));
digitized = zeros(1,ceil(length(lfp)/everyNthSample)); % what port is active? -1 == NULL


%% simulate the arrival of data samples
% cheat a little on the spool up
for idx=1: 320000 %length(lfp)
    
    %% lowpass
    % from http://www.ee.ic.ac.uk/pcheung/teaching/ee3_Study_Project/iir_lab2.pdf
    % iir xfer function : (might have errors...)
    % H(z) = ( b_0 + b_1 * z^-1 ... + b_n * z^-n ) / ( 1 + a_1 * z^-1 ... + a_n * z^-n )
    % becomes :
    % y(n)= b_0*x(n) + b_1*x(n-1) ...  + b_m*x(n-m) - a_1*y(n-1) ...  - a_m*y(n-m)
    % so basically, the result of the last calculation feeds into this one.
    % this means we can convert the calculation into linear algebra,
    % but we need to flip the coefficient order (better above than here,
    % really) because coef 0 should be multiplied by the current data, and
    % that will not happen in the normal orientations in matlab's dot
    % product  
    %lowpassed(idx) = sum(lowpassNumeratorCache.*lowpassNumeratorCoeffs) - sum(lowpassDenominatorCache.*lowpassDenominatorCoeffs);
    %lowpassNumeratorCache = [ lfp(idx) lowpassNumeratorCache(1:end-1) ]; % shift register  
    %lowpassDenominatorCache = [ lowpassed(idx) lowpassDenominatorCache(1:end-1) ];
    for k=1:min(idx,lowpassNCoeff) 
        lowpassed(idx) = lowpassed(idx) ...
            - lowpassed(idx-k+1)*lowpassDenominatorCoeffs(k)...
            + lfp(idx-k+1)*lowpassNumeratorCoeffs(k);
    end
   %% downsample
    
     if ( 0 == mod(idx, everyNthSample) )
         dsIdx = idx/everyNthSample;
         downsampled(dsIdx) = lowpassed(idx);
         %% bandpass  
        %bandpassCache = [ bandpassCache(2:end) lowpassed(idx) ]; % shift register
        %bandpassed(dsIdx) = bandpassCache*bandpassNumeratorCoeffs' + bandpassCache*-bandpassDenominatorCoeffs';
        for k=1:min(dsIdx,bandpassNCoeff) 
            bandpassed(dsIdx) = bandpassed(dsIdx) ...
                - bandpassed(dsIdx-k+1)*bandpassDenominatorCoeffs(k)...
                + downsampled(dsIdx-k+1)*bandpassNumeratorCoeffs(k);
        end
        %% hilbert -- done with FIR
        
        hilbertCache = [ bandpassed(idx/everyNthSample) hilbertCache(1:end-1)  ];
        hilberted(dsIdx)= sum(hilbertCache.*hilbertNumeratorCoeffs);
        %for k=1:min(dsIdx,hilbertNCoeffs)
        %    hilberted(dsIdx)= hilberted(dsIdx) + ...
        %                      bandpassed(dsIdx-k+1)*hilbertNumeratorCoeffs(k);
        %end
         %% CORDIC
         [ angled(dsIdx) , enveloped(dsIdx)] = cordicVector(bandpassed(dsIdx),hilberted(dsIdx),20);
         %% threshold check
         if ( enveloped(dsIdx) * bitvolts < powerThreshold )
             % the output is NULL
             digitized(dsIdx) = -1;
         else
             %% map to digital out
             % i.e. what TTL is currently on
             digitized(dsIdx) = floor(angled(dsIdx)/(359/phaseSegmentsDesired));
         end
    end
end